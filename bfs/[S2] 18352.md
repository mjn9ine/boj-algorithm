# [BOJ] 18352번 특정 거리의 도시 찾기

백준온라인저지(BOJ) :  https://www.acmicpc.net/problem/18352



## 1. 문제 설명

| 시간 제한 | 메모리 제한 | 
| :-------- | :---------- |
| 2 초      | 256 MB      | 

### 문제

어떤 나라에는 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재한다. 모든 도로의 거리는 1이다.

이 때 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력하는 프로그램을 작성하시오. 또한 출발 도시 X에서 출발 도시 X로 가는 최단 거리는 항상 0이라고 가정한다.

예를 들어 N=4, K=2, X=1일 때 다음과 같이 그래프가 구성되어 있다고 가정하자.

![img.png](images/18352_img.png)

이 때 1번 도시에서 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 2인 도시는 4번 도시 뿐이다.  2번과 3번 도시의 경우, 최단 거리가 1이기 때문에 출력하지 않는다.

### 입력

첫째 줄에 도시의 개수 N, 도로의 개수 M, 거리 정보 K, 출발 도시의 번호 X가 주어진다. (2 ≤ N ≤ 300,000, 1 ≤ M ≤ 1,000,000, 1 ≤ K ≤ 300,000, 1 ≤ X ≤ N) 둘째 줄부터 M개의 줄에 걸쳐서 두 개의 자연수 A, B가 공백을 기준으로 구분되어 주어진다. 이는 A번 도시에서 B번 도시로 이동하는 단방향 도로가 존재한다는 의미다. (1 ≤ A, B ≤ N) 단, A와 B는 서로 다른 자연수이다.


### 출력

X로부터 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 K인 모든 도시의 번호를 한 줄에 하나씩 오름차순으로 출력한다.

이 때 도달할 수 있는 도시 중에서, 최단 거리가 K인 도시가 하나도 존재하지 않으면 -1을 출력한다.

#### 예제 입력 1

```
4 4 2 1
1 2
1 3
2 3
2 4
```

#### 예제 출력 1

```
4
```

#### 예제 입력 2

```
4 3 2 1
1 2
1 3
1 4
```

#### 예제 출력 2

```
-1
```

#### 예제 입력 3

```
4 4 1 1
1 2
1 3
2 3
2 4
```

#### 예제 출력 3

```
2
3
```


## 2. 내 소스 코드

```python
import sys
from collections import deque

input = sys.stdin.readline

def bfs(v):
    queue = deque()
    cnt = 0
    queue.append((v, cnt))
    visited[v] = True

    while queue:
        v, cnt = queue.popleft()

        if cnt == k:
            ans.append(v)

        cnt += 1
        for i in graph[v]:
            if not visited[i]:
                queue.append((i, cnt))
                visited[i] = True



n, m, k, x = map(int, input().split())

graph = [[] for _ in range(n + 1)]
visited = [False] * (n + 1)
ans = []

for _ in range(m):
    a, b = map(int, input().split())
    graph[a].append(b)

bfs(x)
if ans:
    ans.sort()
    for i in ans:
        print(i)
else:
    print(-1)
```



## 3. 풀이 & 개선점

```python
 이 문제는 앞서 해결했던 문제들과 결이 비슷했다. 풀기는 비교적 쉬웠는데 제출하는 과정에서 몇 번의 오류가 있었다. 첫번째로 시간초과는 input을 
일반적으로 받았을 때는 입력량이 많아 시간초과가 나왔다. 해결방법은 위처럼 sys.stdin.readline을 이용하면 해결할 수 있었다. 두번째로는 출력이
초과되었는데 문제에서 도시와 도시사이의 도로는 단방향이라고 나와있었지만 습관처럼 양방향으로 해결하려고 해서 그랬던 것 같다. 조금 더 신중하게 문제를
읽고 해결하려는 습관을 다시 찾아야할 것 같다.
```