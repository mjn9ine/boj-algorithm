# [BOJ] 2872번 우리집엔 도서관이 있어

백준온라인저지(BOJ) :  https://www.acmicpc.net/problem/2872



## 1. 문제 설명

| 시간 제한 | 메모리 제한 | 
| :-------- | :---------- |
| 1 초      | 128 MB      | 

### 문제

상근이는 컴퓨터 공학의 일인자가 되기 위해 책을 매우 많이 구매했다. 하지만, 집에 책장이 없어서 책을 탑처럼 쌓아놓고 있다.

오늘은 오랜만에 상근이가 집에서 휴식을 취하는 날이다. 상근이는 책을 알파벳 순서대로 정렬하려고 한다. 사전 순으로 가장 앞서는 책은 가장 위에 놓고, 가장 뒤에 있는 책은 가장 밑에 놓아야 한다. 책을 정렬할 때 사용할 수 있는 방법은 책 하나를 뺀 다음, 가장 위에 놓는 것이다.

책은 1부터 N까지 번호가 책 이름의 사전 순으로 매겨져 있다. 1은 사전 순으로 가장 앞서는 책이다. 따라서, 위에서부터 책의 번호를 읽으면 (1, 2, ..., N)이 되어야 한다. 예를 들어, 책이 3권있고 처음에 (3, 2, 1)로 쌓여있을 때, 2번 만에 사전순으로 책을 쌓을 수 있다. 가장 먼저, 2번 책을 뺀 다음에 가장 위에 놓는다. 그렇게 되면 (2, 3, 1)이 된다. 마지막으로, 1을 뺀 다음 가장 위에 놓으면 (1, 2, 3)이 된다.

현재 책이 어떻게 쌓여있는지가 주어졌을 때, 몇 번만에 사전 순으로 쌓을 수 있는지 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 책의 개수 N이 주어진다. (N ≤ 300,000)

다음 N개 줄에는 가장 위에 있는 책부터 아래에 있는 책까지 순서대로 주어진다.

### 출력

첫째 줄에 몇 번만에 책을 정렬할 수 있는지 출력한다.

#### 예제 입력 1

```
3
3
2
1
```

#### 예제 출력 1

```
2
```


## 2. 내 소스 코드

```python
import sys

N = int(input())

books_num = []

for i in range(N):
    data = sys.stdin.readline().rstrip()
    books_num.append(int(data))

cnt = N

for i in range(N, 0, -1):
    if (books_num[i - 1] == cnt):
        cnt -= 1

print(cnt)
```



## 3. 풀이 & 개선점

```python
 이 문제는 내가 알맞게 풀었다고 생각한 코드가 계속 시간초과에 걸려서 무엇이 문제인지 찾아보려고 했지만 실패하고 누군가의 코드를 참고했다.
 내가 처음에 푼 코드는 아래와 같고, 리스트의 index함수를 이용하여 값을 찾는데 시간이 오래걸리는 것 같다. 정확하진 않기 때문에 더 알아봐야 겠고,
결과적으로 풀이는 카운트를 주어진 숫자와 같게 설정한 후에 값이 있어야 할 자리에 맞는 값이 들어가 있다면 카운트를 줄이는 것이다.
#######
N = int(input())

books_num = []
for _ in range(N):
    data = int(input())
    books_num.append(data)

for i in range(N, 1, -1):
    if (books_num.index(i) < books_num.index(i - 1)):
        break

print(i - 1)
```