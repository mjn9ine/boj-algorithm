# [BOJ] 16953번 A->B

백준온라인저지(BOJ) :  https://www.acmicpc.net/problem/16953



## 1. 문제 설명

| 시간 제한 | 메모리 제한 | 
| :-------- | :---------- |
| 2 초      | 512 MB      | 

### 문제

정수 A를 B로 바꾸려고 한다. 가능한 연산은 다음과 같은 두 가지이다.

* 2를 곱한다.
* 1을 수의 가장 오른쪽에 추가한다.

A를 B로 바꾸는데 필요한 연산의 최솟값을 구해보자.

### 입력

첫째 줄에 A, B (1 ≤ A < B ≤ 109)가 주어진다.

### 출력

A를 B로 바꾸는데 필요한 연산의 최솟값에 1을 더한 값을 출력한다. 만들 수 없는 경우에는 -1을 출력한다.

#### 예제 입력 1

```
2 162
```

#### 예제 출력 1

```
5
```

#### 예제 입력 2

```
4 42
```

#### 예제 출력 2

```
-1
```
#### 예제 입력 3

```
100 40021
```

#### 예제 출력 3

```
5
```

## 2. 내 소스 코드

```python
a, b = map(int, input().split())

cnt = 1

while (True):
    if (b == a):
        break

    elif((b % 2 != 0 and b % 10 != 1) or b < a):
        cnt = -1
        break

    else:
        if (b % 2 == 0):
            b //= 2
            cnt += 1
        else:
            b //= 10
            cnt += 1

print(cnt)
```



## 3. 풀이 & 개선점

```python
 이 문제는 b에서 a를 찾아가는 과정으로 풀 수 있었다. b가 a가 될때까지 2로 나눌 수 없고 10으로 나눈 나머지가 1이 아니거나 b가 a보다 작아진다면 
-1을 출력하고 그렇지 않다면 카운트를 늘려가며 a까지 가는 알고리즘을 이용했다.
 더 효율적인 풀이가 뭐가 있나 보던 중 bfs를 이용하는 방법도 있다는 것을 보게 되었다. 아직 공부가 부족해 적용하기 힘들었지만 빨리 알고리즘을 더
공부해서 다양한 풀이 중 최선을 선택할 수 있어야 할 것 같다.
```